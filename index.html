<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Custom Motel Radio — FE</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* UI minimale e leggibile */
    :root { font-family: ui-sans-serif, system-ui, Arial, sans-serif; }
    body { max-width: 860px; margin: 24px auto; padding: 0 12px; }
    h1 { margin-bottom: 8px; }
    section { border: 1px solid #ddd; border-radius: 10px; padding: 16px; margin: 16px 0; }
    label { font-weight: 600; display: inline-block; margin: 8px 0 4px; }
    input[type="text"], input[type="url"], textarea, select {
      width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 8px;
    }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button {
      padding: 8px 14px; border: 0; border-radius: 8px; cursor: pointer; background: #111; color: #fff;
    }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    #error { margin: 8px 0; color: #a40000; min-height: 1.2em; }
    #player { width: 100%; margin-top: 8px; }
    small.hint { color: #555; }
  </style>
</head>
<body>
  <h1>Custom Motel Radio</h1>
  <p class="hint">FE “stateless”: genera il <strong>testo</strong> dell’intro → lo passa a <strong>/api/tts</strong> → riproduce l’MP3.</p>

  <!-- ====== SEZIONE A: TTS LIBERO (testo → MP3) ====== -->
  <section aria-labelledby="sec-free-tts">
    <h2 id="sec-free-tts">A) TTS libero</h2>
    <label for="freeText">Testo</label>
    <textarea id="freeText" rows="3">Hello from Motel Radio frontend test.</textarea>

    <div class="row">
      <div style="flex:1 1 260px">
        <label for="voiceId">Voice ID (opzionale)</label>
        <input id="voiceId" type="text" placeholder="Lascia vuoto per usare il default del backend" />
      </div>
      <div>
        <label for="langFree">Lingua TTS</label>
        <select id="langFree">
          <option value="it">Italiano</option>
          <option value="en" selected>English</option>
        </select>
      </div>
    </div>

    <div class="row" style="margin-top:8px;">
      <button id="btnTtsFree">Genera TTS</button>
    </div>
  </section>

  <!-- ====== SEZIONE B: INTRO DA LINK SPOTIFY (singola traccia) ====== -->
  <section aria-labelledby="sec-spotify">
    <h2 id="sec-spotify">B) Intro da link Spotify (singola traccia)</h2>

    <label for="trackUrl">Link Spotify della traccia</label>
    <input id="trackUrl" type="url" placeholder="https://open.spotify.com/track/..." />

    <div class="row" style="margin-top:8px;">
      <!-- Flusso “stateless”: prima solo testo (plain), poi TTS -->
      <button id="btnOnlyText">1) Genera solo testo</button>
      <button id="btnTextAndTts">2) Testo + TTS</button>
      <div>
        <label for="langIntro" style="margin:0 0 0 8px;">Lingua TTS</label>
        <select id="langIntro">
          <option value="it" selected>Italiano</option>
          <option value="en">English</option>
        </select>
      </div>
    </div>

    <label for="generatedText" style="margin-top:10px;">Testo generato (anteprima)</label>
    <textarea id="generatedText" rows="3" readonly></textarea>
    <small class="hint">Questo è il testo che verrà passato a /api/tts. Puoi copiarlo e modificarlo per prove manuali in A).</small>
  </section>

  <!-- ====== AREA ERRORI + PLAYER ====== -->
  <div id="error" role="alert" aria-live="polite"></div>
  <audio id="player" controls></audio>

  <script>
  // ============================
  // CONFIG BASE BACKEND
  // ============================
  const BASE = "http://localhost:8000"; // cambia se il backend è altrove

  // ----------------------------
  // Helper DOM + UX
  // ----------------------------
  const $ = (sel) => document.querySelector(sel);
  const player = $("#player");         // unico <audio> in pagina
  const errBox = $("#error");          // <div id="error"> per messaggi

  function setError(msg) {
    // Visualizza eventuali messaggi d'errore
    errBox && (errBox.textContent = msg || "");
  }

  function isValidTrackUrl(u) {
    // Accetta URL con o senza intl-xx e URI spotify:track:ID
    return /open\.spotify\.com\/(?:intl-[a-z]{2}\/)?track\//.test(u)
        || /^spotify:track:[A-Za-z0-9]{22}$/.test(u);
  }

  async function playBlob(blob) {
    // Collega il Blob MP3 al player e riproduci
    const url = URL.createObjectURL(blob);
    player.src = url;
    try { await player.play(); } catch (_) {}
    player.onended = () => URL.revokeObjectURL(url);
  }

  // ----------------------------
  // API wrappers (FE → BE)
  // ----------------------------

  async function apiIntroText(trackUrl) {
    /**
     * Chiede l’introduzione all’endpoint "solo testo".
     * RITORNA SEMPRE UNA STRINGA:
     * - se il BE risponde JSON, estrae .text
     * - se il BE risponde text/plain, usa direttamente il body
     */
    const res = await fetch(`${BASE}/api/intro-from-track-text?debug=0`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ track_url: trackUrl }), // chiave corretta per il BE
    });

    if (!res.ok) {
      // mostriamo il body d'errore del BE per debug rapido
      throw new Error(await res.text());
    }

    const ct = res.headers.get("content-type") || "";

    if (ct.includes("application/json")) {
      // Se è JSON, estrai la sola proprietà 'text'
      const data = await res.json();
      if (data && typeof data.text === "string") {
        return data.text.trim();
      }
      // Fallback: non dovrebbe capitare, ma evitiamo che arrivi [object Object] al TTS
      throw new Error("Risposta JSON inattesa: manca 'text'.");
    }

    // text/plain: usa direttamente il body grezzo
    return (await res.text()).trim();
  }

  async function apiTTS(text, language_code, voiceId) {
    /**
     * Invia il testo a /api/tts e ritorna un Blob MP3.
     * La chiave di ElevenLabs resta al sicuro nel backend.
     */
    // Pre-normalizzazione (migliora la resa TTS radiofonica)
    const clean = String(text).replace(/\s+/g, " ").trim();

    const payload = { text: clean, language_code };
    if (voiceId) payload.voiceId = voiceId; // opzionale

    const res = await fetch(`${BASE}/api/tts`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    const ct = res.headers.get("content-type") || "";
    if (!res.ok || !ct.includes("audio/mpeg")) {
      // Se il BE risponde errore o un mimetype diverso, mostriamo il body per capire il motivo
      throw new Error(`TTS error ${res.status}: ${await res.text()}`);
    }
    return res.blob(); // Blob MP3
  }

  // ============================
  // A) TTS LIBERO (testo → MP3)
  // ============================
  $("#btnTtsFree")?.addEventListener("click", async () => {
    setError("");
    const btn = $("#btnTtsFree");
    const text = $("#freeText")?.value?.trim() || "";
    const voiceId = $("#voiceId")?.value?.trim();
    const lang = $("#langFree")?.value || "en";

    if (!text) { setError("Inserisci del testo."); return; }

    btn.disabled = true; const old = btn.textContent; btn.textContent = "Generazione...";
    try {
      const mp3 = await apiTTS(text, lang, voiceId || undefined);
      await playBlob(mp3);
    } catch (e) {
      setError(e.message || "Errore TTS");
    } finally {
      btn.disabled = false; btn.textContent = old;
    }
  });

  // ============================================
  // B1) INTRO DA SPOTIFY — SOLO TESTO (plain)
  // ============================================
  $("#btnOnlyText")?.addEventListener("click", async () => {
    setError("");
    const btn = $("#btnOnlyText");
    const link = $("#trackUrl")?.value?.trim() || "";

    if (!isValidTrackUrl(link)) { setError("Inserisci un link Spotify valido a UNA traccia."); return; }

    btn.disabled = true; const old = btn.textContent; btn.textContent = "Generazione testo...";
    try {
      const intro = await apiIntroText(link);                // ← stringa PULITA
      $("#generatedText").value = intro;                     // anteprima SOLO testo
    } catch (e) {
      setError(e.message || "Errore generazione testo");
    } finally {
      btn.disabled = false; btn.textContent = old;
    }
  });

  // ==================================================
  // B2) INTRO DA SPOTIFY — TESTO + TTS (pipeline)
  // ==================================================
  $("#btnTextAndTts")?.addEventListener("click", async () => {
    setError("");
    const btn = $("#btnTextAndTts");
    const link = $("#trackUrl")?.value?.trim() || "";
    const lang = $("#langIntro")?.value || "it";

    if (!isValidTrackUrl(link)) { setError("Inserisci un link Spotify valido a UNA traccia."); return; }

    btn.disabled = true; const old = btn.textContent; btn.textContent = "Intro + TTS...";
    try {
      // 1) Ottieni SOLO testo (estrae .text se il BE manda JSON)
      const intro = await apiIntroText(link);
      $("#generatedText").value = intro;     // mostra cosa invierai a 11Labs

      // 2) Invio a /api/tts e riproduzione
      const mp3 = await apiTTS(intro, lang /* voiceId opzionale qui se vuoi forzare */);
      await playBlob(mp3);
    } catch (e) {
      setError(e.message || "Errore intro/TTS");
    } finally {
      btn.disabled = false; btn.textContent = old;
    }
  });
</script>
</body>
</html>
